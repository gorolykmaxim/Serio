package org.serio.core.showscrawler.tasks;

import org.apache.commons.lang3.StringUtils;
import org.serio.core.showcrawlerlogstorage.CrawlLogEntry;
import org.serio.core.showscrawler.crawler.step.CrawlerStep;

import java.util.ArrayList;
import java.util.List;

/**
 * A decorator of a {@link CrawlerStepTask}, that logs information about the decorated crawler step.
 *
 * <p>The task logs:</p>
 * <ul>
 *     <li>general information about the decorated crawler step, such as it's name and it's attributes</li>
 *     <li>input data, passed to the step</li>
 *     <li>output data, generated by the step</li>
 * </ul>
 *
 * <p>Due to a possibility of a high amount of data, processed, both input and output data might be truncated
 * if necessary.</p>
 */
public class LoggingTaskDecorator implements CrawlerStepTask {
    private final CrawlerStepTask task;
    private final CrawlerStep step;
    private final List<CrawlLogEntry> log;
    private final long detailsLength;

    /**
     * Construct a logging crawler step task decorator.
     *
     * @param task task to decorate
     * @param step crawler step being executed
     * @param log the overall crawling log to append a generated entry to
     * @param detailsLength maximum length of crawler step input and ouput data that will be stored in the log entry
     */
    public LoggingTaskDecorator(CrawlerStepTask task, CrawlerStep step, List<CrawlLogEntry> log, long detailsLength) {
        this.task = task;
        this.step = step;
        this.log = log;
        this.detailsLength = detailsLength;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<String> execute(List<String> input) {
        List<String> output = task.execute(input);
        log.add(new CrawlLogEntry(step.toString(), truncateAndSerialize(input), truncateAndSerialize(output)));
        return output;
    }

    private String truncateAndSerialize(List<String> data) {
        long symbolsCount = 0;
        List<String> dataToBeSerialized = new ArrayList<>();
        boolean wasTruncated = false;
        for (int i = 0; i < data.size(); i++) {
            if (symbolsCount >= detailsLength) {
                wasTruncated = true;
                break;
            }
            String part = data.get(i);
            dataToBeSerialized.add(part);
            symbolsCount += part.length();
        }
        String unCutDataToBeSerialized = dataToBeSerialized.toString();
        if (!wasTruncated && unCutDataToBeSerialized.length() > detailsLength) {
            wasTruncated = true;
        }
        String truncatedData = StringUtils.truncate(dataToBeSerialized.toString(), (int) detailsLength);
        return wasTruncated ? truncatedData + "..." : truncatedData;
    }
}
